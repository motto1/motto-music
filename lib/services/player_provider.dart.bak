import 'package:flutter/foundation.dart';
import 'package:media_kit/media_kit.dart';
import 'dart:async';
import 'dart:math' as math;
import '../database/database.dart';
import 'audio_loader_service.dart';
import '../storage/player_state_storage.dart';
import '../contants/app_contants.dart' show PlayMode;
import 'bilibili/stream_service.dart';
import 'bilibili/api_client.dart';
import 'bilibili/api_service.dart';
import 'bilibili/cookie_manager.dart';
import 'bilibili/audio_cache_service.dart';
import 'package:drift/drift.dart';
import 'lyrics/lyric_service.dart';
import '../models/lyrics/lyric_models.dart';
import '../utils/lyric_parser.dart';

class PlayerProvider with ChangeNotifier {
  // ç›´æ¥ä½¿ç”¨ Player å®ä¾‹ï¼Œä¸å†é€šè¿‡ AudioService
  final Player _player = Player(
    configuration: const PlayerConfiguration(
      title: "Motto Music",
    ),
  );

  late final PlayerStateStorage playerState;
  late final BilibiliStreamService _bilibiliStreamService;
  late final BilibiliAudioCacheService _bilibiliAudioCacheService;
  late final AudioLoaderService _audioLoaderService;
  late final BilibiliApiService _bilibiliApiService;
  Song? _currentSong;
  bool _isPlaying = false;
  bool _isLoading = false;
  String? _errorMessage;

  double _volume = 1.0;

  final ValueNotifier<Duration> _position = ValueNotifier(Duration.zero);

  Duration _duration = Duration.zero;

  PlayMode _playMode = PlayMode.loop;

  List<Song> _playlist = [];
  List<Song> _originalPlaylist = [];
  List<Song> _shuffledPlaylist = [];
  int _currentIndex = -1;

  final math.Random _random = math.Random();

  // æ­Œè¯ç›¸å…³çŠ¶æ€
  ParsedLrc? _currentLyrics;
  bool _isLoadingLyrics = false;
  String? _lyricsError;

  StreamSubscription? _playingSub;
  StreamSubscription? _positionSub;
  StreamSubscription? _durationSub;
  StreamSubscription? _completedSub;

  bool _isHandlingComplete = false;
  Timer? _completeDebounceTimer;

  // Getters
  Song? get currentSong => _currentSong;
  bool get isPlaying => _isPlaying;
  bool get isLoading => _isLoading;
  String? get errorMessage => _errorMessage;
  ValueNotifier<Duration> get position => _position;
  Duration get duration => _duration;
  PlayMode get playMode => _playMode;
  List<Song> get playlist => List.unmodifiable(_playlist);
  int get currentIndex => _currentIndex;
  Player get player => _player;
  double get volume => _volume;
  AudioLoaderService get audioLoaderService => _audioLoaderService;

  // æ­Œè¯ç›¸å…³ Getters
  ParsedLrc? get currentLyrics => _currentLyrics;
  bool get isLoadingLyrics => _isLoadingLyrics;
  String? get lyricsError => _lyricsError;

  bool get hasPrevious =>
      playMode == PlayMode.shuffle ? true : _currentIndex > 0;
  bool get hasNext => playMode == PlayMode.shuffle
      ? true
      : _currentIndex < _playlist.length - 1;

  static void Function()? onSongChange;

  PlayerProvider() {
    // åˆå§‹åŒ– Bilibili æµæœåŠ¡
    final cookieManager = CookieManager();
    final apiClient = BilibiliApiClient(cookieManager);
    _bilibiliStreamService = BilibiliStreamService(apiClient);
    _bilibiliApiService = BilibiliApiService(apiClient);
    _bilibiliAudioCacheService = BilibiliAudioCacheService(
      MusicDatabase.database,
      _bilibiliStreamService,
    );
    _audioLoaderService = AudioLoaderService(
      _player,
      cacheService: _bilibiliAudioCacheService,
      apiService: _bilibiliApiService,
    );

    // è®¾ç½®ä¸‹è½½è¿›åº¦å›è°ƒ
    _audioLoaderService.onDownloadProgress = (received, total) {
      if (total > 0) {
        final progress = (received / total * 100).toStringAsFixed(0);
        print('  ä¸‹è½½è¿›åº¦: $progress%');
        // è¿™é‡Œå¯ä»¥é€šè¿‡ notifyListeners æ›´æ–° UI æ˜¾ç¤ºä¸‹è½½è¿›åº¦
      }
    };

    _initializeListeners();
  }

  void _initializeListeners() {
    // ğŸ”§ Streamç›‘å¬å™¨ï¼šå”¯ä¸€çœŸç›¸æºï¼Œæ‰€æœ‰æ’­æ”¾çŠ¶æ€å˜åŒ–éƒ½ç”±æ­¤åŒæ­¥
    _playingSub = player.stream.playing.listen((playing) {
      // åŠ è½½æœŸé—´å¿½ç•¥streamé€šçŸ¥
      if (_isLoading) return;

      // ç›´æ¥åŒæ­¥çŠ¶æ€ï¼Œç§»é™¤æ¡ä»¶åˆ¤æ–­é¿å…çŠ¶æ€ä¸ä¸€è‡´
      if (_isPlaying != playing && !_isHandlingComplete) {
        print('ğŸ”„ æ’­æ”¾çŠ¶æ€æ›´æ–°: $_isPlaying -> $playing');
        _isPlaying = playing;
        notifyListeners();
      }
    });

    // ä½ç½®æ›´æ–°
    _positionSub = player.stream.position.listen((pos) {
      _position.value = pos;
    });

    // æ€»æ—¶é•¿
    _durationSub = player.stream.duration.listen((dur) {
      _duration = dur;
      notifyListeners();
    });

    // æ’­æ”¾å®Œæˆ
    _completedSub = player.stream.completed.listen((completed) {
      if (completed) {
        _handleSongCompleteWithDebounce();
      }
    });

    // åˆå§‹åŒ–çŠ¶æ€
    PlayerStateStorage.getInstance().then((state) {
      playerState = state;
      _currentSong = state.currentSong;
      _playlist = state.playlist;
      _originalPlaylist = state.playlist;
      _shuffledPlaylist = state.playlist;
      _volume = state.volume;
      _playMode = state.playMode;
      _position.value = state.position;
      _isPlaying = state.isPlaying;
      if (_currentSong != null) {
        playSong(
          _currentSong!,
          playlist: _playlist,
          index: _playlist.indexWhere((s) => s.id == _currentSong!.id),
          shuffle: false,
          playNow: false,
        );
      }
      setVolume(_volume);
      notifyListeners();
    });
  }

  void _handleSongCompleteWithDebounce() {
    _completeDebounceTimer?.cancel();
    _completeDebounceTimer = Timer(const Duration(milliseconds: 100), () {
      if (!_isHandlingComplete) {
        _onSongComplete();
      }
    });
  }

  void _createShuffledPlaylist() {
    if (_originalPlaylist.isEmpty) return;

    _shuffledPlaylist = List.from(_originalPlaylist);

    if (_currentSong != null) {
      _shuffledPlaylist.removeWhere((song) => song.id == _currentSong!.id);
      _shuffledPlaylist.insert(0, _currentSong!);
    }

    if (_shuffledPlaylist.length > 1) {
      final songsToShuffle = _shuffledPlaylist.sublist(1);
      songsToShuffle.shuffle(_random);
      _shuffledPlaylist = [_shuffledPlaylist.first, ...songsToShuffle];
    }
  }

  int _getCurrentSongIndexInOriginal() {
    if (_currentSong == null) return -1;
    return _originalPlaylist.indexWhere((song) => song.id == _currentSong!.id);
  }

  Future<void> playSong(
    Song song, {
    List<Song>? playlist,
    int? index,
    bool shuffle = true,
    bool playNow = true,
  }) async {
    try {
      // ğŸ”§ è°ƒè¯•ä¿¡æ¯ï¼šæ‰“å°æ­Œæ›²å…ƒæ•°æ®
      debugPrint('[æ’­æ”¾è°ƒè¯•] ========== å¼€å§‹æ’­æ”¾ ==========');
      debugPrint('[æ’­æ”¾è°ƒè¯•] æ­Œæ›²: ${song.title}');
      debugPrint('[æ’­æ”¾è°ƒè¯•] è‰ºæœ¯å®¶: ${song.artist ?? "æœªçŸ¥"}');
      debugPrint('[æ’­æ”¾è°ƒè¯•] å°é¢è·¯å¾„: ${song.albumArtPath ?? "æ— "}');
      debugPrint('[æ’­æ”¾è°ƒè¯•] æ—¶é•¿: ${song.duration}');
      debugPrint('[æ’­æ”¾è°ƒè¯•] æ¥æº: ${song.source}');
      
      // ç«‹å³æ›´æ–°UIçŠ¶æ€
      _isLoading = true;
      _errorMessage = null;
      _isHandlingComplete = false;
      _currentSong = song;
      notifyListeners();

      // å¤„ç†æ’­æ”¾åˆ—è¡¨é€»è¾‘
      if (playlist != null) {
        _originalPlaylist = List.from(playlist);

        if (_playMode == PlayMode.shuffle && shuffle) {
          _createShuffledPlaylist();
          _playlist = _shuffledPlaylist;
          _currentIndex = _shuffledPlaylist.indexWhere((s) => s.id == song.id);
        } else {
          _playlist = List.from(playlist);
          _currentIndex = index ?? 0;
          if (_playMode == PlayMode.shuffle) {
            _createShuffledPlaylist();
          }
        }
      } else if (_originalPlaylist.isEmpty ||
          !_originalPlaylist.any((s) => s.id == song.id)) {
        _originalPlaylist = [song];
        _shuffledPlaylist = [song];
        _playlist = [song];
        _currentIndex = 0;
      } else {
        if (_playMode == PlayMode.shuffle) {
          _currentIndex = _shuffledPlaylist.indexWhere((s) => s.id == song.id);
          _playlist = _shuffledPlaylist;
        } else {
          _currentIndex = _originalPlaylist.indexWhere((s) => s.id == song.id);
          _playlist = _originalPlaylist;
        }
      }

      // ä½¿ç”¨æ–°çš„ AudioLoaderService æ’­æ”¾
      await _audioLoaderService.playSong(song, playNow: playNow);

      // æ’­æ”¾æˆåŠŸåï¼Œé¢„åŠ è½½ä¸‹ä¸€é¦–
      _preloadNextSong();

      // ğŸ”§ ç»“æŸåŠ è½½çŠ¶æ€ï¼Œå¹¶æ‰‹åŠ¨åŒæ­¥æ’­æ”¾çŠ¶æ€ï¼ˆå› ä¸ºåŠ è½½æœŸé—´æµæ›´æ–°è¢«å¿½ç•¥ï¼‰
      _isLoading = false;
      _isPlaying = player.state.playing;  // ä» player ç›´æ¥è¯»å–å½“å‰çŠ¶æ€
      notifyListeners();

      // ğŸ”§ æ•°æ®åº“æ›´æ–°æ“ä½œç‹¬ç«‹å¤„ç†ï¼Œå¤±è´¥ä¸å½±å“æ’­æ”¾çŠ¶æ€
      try {
        // æ›´æ–°æ•°æ®åº“æ’­æ”¾è®¡æ•°
        if (song.id < 0) {
          // ä¸´æ—¶Songå¯¹è±¡ï¼ˆåœ¨çº¿æ”¶è—å¤¹ï¼‰
          // å…ˆå°è¯•æŸ¥è¯¢æ˜¯å¦å·²å­˜åœ¨ç›¸åŒçš„æ­Œæ›²ï¼ˆæ ¹æ®bvid+cidåˆ¤æ–­ï¼‰
          Song? existingSong;
          if (song.bvid != null && song.cid != null) {
            existingSong = await MusicDatabase.database.getSongByBvidAndCid(
              song.bvid!,
              song.cid!,
            );
            if (existingSong != null) {
              print('ğŸ“Œ å‘ç°å·²å­˜åœ¨æ­Œæ›²ï¼ŒID: ${existingSong.id}');
            }
          }
          
          if (existingSong != null) {
            // å·²å­˜åœ¨ï¼Œæ›´æ–°æ’­æ”¾è®¡æ•°
            await MusicDatabase.database.updateSong(
              existingSong.copyWith(
                lastPlayedTime: DateTime.now(),
                playedCount: existingSong.playedCount + 1,
              ),
            );
            _currentSong = existingSong.copyWith(
              lastPlayedTime: DateTime.now(),
              playedCount: existingSong.playedCount + 1,
            );
          } else {
            // ä¸å­˜åœ¨ï¼Œæ’å…¥æ–°è®°å½•
            final newId = await MusicDatabase.database.insertSong(
              song.copyWith(
                lastPlayedTime: DateTime.now(),
                playedCount: 1,
              ).toCompanion(false),
            );
            _currentSong = song.copyWith(
              id: newId,
              lastPlayedTime: DateTime.now(),
              playedCount: 1,
            );
          }
        } else {
          // å·²å­˜åœ¨çš„æ­Œæ›²ï¼Œç›´æ¥æ›´æ–°
          await MusicDatabase.database.updateSong(
            song.copyWith(
              lastPlayedTime: DateTime.now(),
              playedCount: song.playedCount + 1,
            ),
          );
        }
      } catch (dbError) {
        // æ•°æ®åº“æ“ä½œå¤±è´¥ä»…è®°å½•æ—¥å¿—ï¼Œä¸å½±å“æ’­æ”¾
        print('âš ï¸ æ•°æ®åº“æ›´æ–°å¤±è´¥ï¼ˆä¸å½±å“æ’­æ”¾ï¼‰: $dbError');
      }

      playerState.setCurrentSong(song);
      playerState.setPlaylist(_playlist);
      
      // è‡ªåŠ¨åŠ è½½æ­Œè¯
      loadLyrics();
      
    } catch (e) {
      print('âŒ æ’­æ”¾å¤±è´¥: $e');
      _isLoading = false;
      _isPlaying = false;
      _errorMessage = 'æ’­æ”¾å¤±è´¥: ${e.toString()}';
      notifyListeners();
    }
  }
  
  /// é¢„åŠ è½½ä¸‹ä¸€é¦–æ­Œæ›²
  void _preloadNextSong() {
    if (_playlist.isEmpty || _currentIndex < 0) return;
    
    // è®¡ç®—ä¸‹ä¸€é¦–çš„ç´¢å¼•
    int nextIndex;
    if (_playMode == PlayMode.shuffle || _playMode == PlayMode.loop) {
      nextIndex = (_currentIndex + 1) % _playlist.length;
    } else if (_playMode == PlayMode.sequence) {
      if (_currentIndex < _playlist.length - 1) {
        nextIndex = _currentIndex + 1;
      } else {
        return; // åºåˆ—æ’­æ”¾åˆ°æœ€åä¸€é¦–ï¼Œä¸é¢„åŠ è½½
      }
    } else {
      return; // å•æ›²æ’­æ”¾ä¸é¢„åŠ è½½
    }
    
    final nextSong = _playlist[nextIndex];
    
    // å¼‚æ­¥é¢„åŠ è½½ï¼Œä¸é˜»å¡å½“å‰æ’­æ”¾
    Future(() async {
      try {
        await _audioLoaderService.preloadSong(nextSong);
        print('âœ… å·²é¢„åŠ è½½ä¸‹ä¸€é¦–: ${nextSong.title}');
      } catch (e) {
        print('âš ï¸ é¢„åŠ è½½ä¸‹ä¸€é¦–å¤±è´¥: $e');
      }
    });
  }

  Future<void> togglePlay() async {
    if (_currentSong == null) return;
    if (_isPlaying) {
      await _pausePlayback();
    } else {
      await _resumePlayback();
    }
  }

  Future<void> _pausePlayback() async {
    // ç§»é™¤ _isPlaying æ£€æŸ¥ï¼Œè®© player è‡ªå·±åˆ¤æ–­æ˜¯å¦éœ€è¦æš‚åœ
    if (_currentSong == null) return;

    try {
      print('â¸ï¸ æš‚åœæ’­æ”¾');
      await _player.pause();
      // æ‰‹åŠ¨åŒæ­¥çŠ¶æ€ï¼Œé¿å…æµæ›´æ–°å»¶è¿Ÿ
      _isPlaying = player.state.playing;
      notifyListeners();
    } catch (e) {
      print('âŒ æš‚åœå¤±è´¥: $e');
      _errorMessage = 'æš‚åœå¤±è´¥: ${e.toString()}';
      notifyListeners();
    }
  }

  Future<void> _resumePlayback() async {
    print('ğŸ” _resumePlayback è¢«è°ƒç”¨');
    print('  _currentSong: ${_currentSong?.title ?? "null"}');
    print('  _isPlaying: $_isPlaying');
    print('  _isLoading: $_isLoading');

    // ğŸ”§ å…³é”®ä¿®å¤ï¼šå¦‚æœæ²¡æœ‰å½“å‰æ­Œæ›²ï¼Œå°è¯•ä»æ’­æ”¾åˆ—è¡¨æ’­æ”¾ç¬¬ä¸€é¦–
    if (_currentSong == null) {
      print('âš ï¸ æ²¡æœ‰å½“å‰æ­Œæ›²');

      // æ£€æŸ¥æ˜¯å¦æœ‰æ’­æ”¾åˆ—è¡¨
      if (_playlist.isNotEmpty) {
        print('  â†’ ä»æ’­æ”¾åˆ—è¡¨æ’­æ”¾ç¬¬ä¸€é¦–æ­Œæ›²');
        await playSong(_playlist[0], playNow: true);
        return;
      } else {
        print('  â†’ æ’­æ”¾åˆ—è¡¨ä¸ºç©ºï¼Œæ— æ³•æ’­æ”¾');
        return;
      }
    }

    try {
      print('â–¶ï¸ æ‰§è¡Œæ¢å¤æ’­æ”¾');
      await _player.play();
      print('âœ… resume() è°ƒç”¨å®Œæˆ');
      // æ‰‹åŠ¨åŒæ­¥çŠ¶æ€ï¼Œé¿å…æµæ›´æ–°å»¶è¿Ÿ
      _isPlaying = player.state.playing;
      notifyListeners();
    } catch (e) {
      print('âŒ æ¢å¤æ’­æ”¾å¤±è´¥: $e');
      _errorMessage = 'æ’­æ”¾å¤±è´¥: ${e.toString()}';
      notifyListeners();
    }
  }

  Future<void> stop() async {
    try {
      print('â¹ï¸ åœæ­¢æ’­æ”¾');
      _isHandlingComplete = true;
      await _player.stop();
      _currentSong = null;
      _isPlaying = false;  // ğŸ”§ ä¸»åŠ¨è®¾ç½®çŠ¶æ€
      _position.value = Duration.zero;
      _errorMessage = null;
      notifyListeners();
    } catch (e) {
      print('âŒ åœæ­¢å¤±è´¥: $e');
      _errorMessage = 'åœæ­¢å¤±è´¥: ${e.toString()}';
      notifyListeners();
    } finally {
      Timer(const Duration(milliseconds: 200), () {
        _isHandlingComplete = false;
      });
    }
  }

  Future<void> previous() async {
    if (_playlist.isEmpty) return;

    if (_playMode == PlayMode.shuffle) {
      if (_currentIndex > 0) {
        _currentIndex--;
      } else {
        _currentIndex = _playlist.length - 1;
      }
      await playSong(_playlist[_currentIndex], shuffle: false);
      onSongChange?.call();
      return;
    }

    if (!hasPrevious &&
        _playMode != PlayMode.loop &&
        _playMode != PlayMode.singleLoop) return;

    if ((_playMode == PlayMode.loop || _playMode == PlayMode.singleLoop) &&
        !hasPrevious) {
      _currentIndex = _playlist.length - 1;
    } else {
      _currentIndex--;
    }
    await playSong(_playlist[_currentIndex], shuffle: false);
    onSongChange?.call();
  }

  Future<void> next() async {
    if (_playlist.isEmpty) {
      print('âš ï¸ æ’­æ”¾åˆ—è¡¨ä¸ºç©ºï¼Œæ— æ³•æ’­æ”¾ä¸‹ä¸€é¦–');
      return;
    }

    if (_playMode == PlayMode.shuffle) {
      if (_currentIndex < _playlist.length - 1) {
        _currentIndex++;
      } else {
        _currentIndex = 0;
      }
      
      await playSong(_playlist[_currentIndex], shuffle: false);
      onSongChange?.call();
      return;
    }

    if (!hasNext &&
        _playMode != PlayMode.loop &&
        _playMode != PlayMode.singleLoop) {
      print('âš ï¸ æ²¡æœ‰ä¸‹ä¸€é¦–ä¸”éå¾ªç¯æ¨¡å¼');
      return;
    }

    if ((_playMode == PlayMode.loop || _playMode == PlayMode.singleLoop) &&
        !hasNext) {
      _currentIndex = 0;
    } else {
      _currentIndex++;
    }
    
    await playSong(_playlist[_currentIndex], shuffle: false);
    onSongChange?.call();
  }

  Future<void> seekTo(Duration position) async {
    try {
      await _player.seek(position);
      // playerState.setPosition(position);
    } catch (e) {
      _errorMessage = 'è·³è½¬å¤±è´¥: ${e.toString()}';
      notifyListeners();
    }
  }

  Future<void> setVolume(double volume) async {
    try {
      // å…è®¸éŸ³é‡èŒƒå›´ 0.0 - 1.5ï¼ˆ150%ï¼‰ï¼Œç”¨äºéŸ³é‡å¢å¼º
      _volume = volume.clamp(0.0, 1.5);
      await player.setVolume(_volume * 100);
      playerState.setVolume(volume);
      notifyListeners();
    } catch (e) {
      _errorMessage = 'è®¾ç½®éŸ³é‡å¤±è´¥: ${e.toString()}';
      notifyListeners();
    }
  }

  Future<void> toggleMute() async {
    if (_volume > 0) {
      await setVolume(0);
    } else {
      await setVolume(1.0);
    }
  }

  void setPlayMode(PlayMode mode) {
    if (_playMode == mode) return;

    final previousMode = _playMode;
    _playMode = mode;
    _handlePlayModeChange(previousMode, mode);
    notifyListeners();
    playerState.setPlayMode(mode);
  }

  List<Song> currentPlaylists() {
    return _playlist;
  }

  void _handlePlayModeChange(PlayMode previousMode, PlayMode newMode) {
    if (previousMode == PlayMode.shuffle && newMode != PlayMode.shuffle) {
      _restoreOriginalPlaylist();
    } else if (previousMode != PlayMode.shuffle &&
        newMode == PlayMode.shuffle) {
      _switchToShuffleMode();
    }
  }

  void _restoreOriginalPlaylist() {
    if (_originalPlaylist.isEmpty) return;
    _playlist = List.from(_originalPlaylist);
    if (_currentSong != null) {
      _currentIndex = _getCurrentSongIndexInOriginal();
      if (_currentIndex == -1) _currentIndex = 0;
    }
  }

  void _switchToShuffleMode() {
    if (_originalPlaylist.isEmpty) return;
    _createShuffledPlaylist();
    _playlist = _shuffledPlaylist;
    if (_currentSong != null) {
      _currentIndex = _shuffledPlaylist.indexWhere(
        (s) => s.id == _currentSong!.id,
      );
      if (_currentIndex == -1) _currentIndex = 0;
    }
  }

  void setPlaylist(List<Song> songs, {int currentIndex = 0}) {
    _originalPlaylist = List.from(songs);
    _currentIndex = currentIndex.clamp(0, songs.length - 1);

    if (_playMode == PlayMode.shuffle) {
      if (songs.isNotEmpty) {
        _currentSong = songs[_currentIndex];
        _createShuffledPlaylist();
        _playlist = _shuffledPlaylist;
        _currentIndex = _shuffledPlaylist.indexWhere(
          (s) => s.id == _currentSong!.id,
        );
      }
    } else {
      _playlist = List.from(songs);
    }

    if (songs.isNotEmpty) {
      _currentSong = songs[currentIndex.clamp(0, songs.length - 1)];
    }
    notifyListeners();
  }

  void addToPlaylist(Song song) {
    _originalPlaylist.add(song);

    if (_playMode == PlayMode.shuffle) {
      if (_shuffledPlaylist.isEmpty) {
        _shuffledPlaylist.add(song);
      } else {
        final randomIndex = _random.nextInt(_shuffledPlaylist.length + 1);
        _shuffledPlaylist.insert(randomIndex, song);
      }
      _playlist = _shuffledPlaylist;
    } else {
      _playlist.add(song);
    }
    notifyListeners();
  }

  void removeFromPlaylist(int index) {
    if (index < 0 || index >= _playlist.length) return;

    final removedSong = _playlist[index];
    _playlist.removeAt(index);
    _originalPlaylist.removeWhere((song) => song.id == removedSong.id);

    if (_playMode == PlayMode.shuffle) {
      _shuffledPlaylist.removeWhere((song) => song.id == removedSong.id);
    }

    if (index < _currentIndex) {
      _currentIndex--;
    } else if (index == _currentIndex) {
      if (_currentIndex >= _playlist.length) {
        _currentIndex = _playlist.length - 1;
      }
      if (_playlist.isEmpty) {
        stop();
      } else {
        _currentSong = _playlist[_currentIndex];
      }
    }
    notifyListeners();
  }

  /// è°ƒæ•´æ’­æ”¾åˆ—è¡¨é¡ºåºï¼ˆæ‹–åŠ¨æ’åºï¼‰
  void reorderPlaylist(int oldIndex, int newIndex) {
    if (oldIndex < 0 || oldIndex >= _playlist.length) return;
    if (newIndex < 0 || newIndex >= _playlist.length) return;
    if (oldIndex == newIndex) return;

    // è°ƒæ•´ newIndexï¼ˆFlutter ReorderableListView çš„æ ‡å‡†é€»è¾‘ï¼‰
    if (newIndex > oldIndex) {
      newIndex -= 1;
    }

    // è·å–è¢«ç§»åŠ¨çš„æ­Œæ›²
    final movedSong = _playlist.removeAt(oldIndex);
    _playlist.insert(newIndex, movedSong);

    // åŒæ­¥æ›´æ–°åŸå§‹æ’­æ”¾åˆ—è¡¨
    _originalPlaylist.clear();
    _originalPlaylist.addAll(_playlist);

    // æ›´æ–°å½“å‰æ’­æ”¾ç´¢å¼•
    if (_currentSong != null) {
      _currentIndex = _playlist.indexWhere((song) => song.id == _currentSong!.id);
    }

    // ä¿å­˜åˆ°æŒä¹…åŒ–å­˜å‚¨
    playerState.setPlaylist(_playlist);
    
    notifyListeners();
    print('ğŸ”„ æ’­æ”¾åˆ—è¡¨å·²é‡æ–°æ’åº: $oldIndex -> $newIndex');
  }

  void reshufflePlaylist() {
    if (_playMode != PlayMode.shuffle || _originalPlaylist.isEmpty) return;

    _createShuffledPlaylist();
    _playlist = _shuffledPlaylist;

    if (_currentSong != null) {
      _currentIndex = _shuffledPlaylist.indexWhere(
        (s) => s.id == _currentSong!.id,
      );
      if (_currentIndex == -1) _currentIndex = 0;
    }
    notifyListeners();
  }

  void clearError() {
    _errorMessage = null;
    notifyListeners();
  }

  void _onSongComplete() {
    if (_isHandlingComplete) return;
    _isHandlingComplete = true;

    try {
      switch (_playMode) {
        case PlayMode.single:
          _isPlaying = false;
          _position.value = Duration.zero;
          break;
        case PlayMode.singleLoop:
          if (_currentSong != null) {
            Future.microtask(() {
              seekTo(Duration.zero);
              _player.play();
            });
          }
          break;
        case PlayMode.sequence:
          if (hasNext) {
            Future.microtask(() => next());
          } else {
            _isPlaying = false;
            _position.value = Duration.zero;
          }
          break;
        case PlayMode.loop:
        case PlayMode.shuffle:
          Future.microtask(() => next());
          break;
      }
      notifyListeners();
    } finally {
      Timer(const Duration(milliseconds: 500), () {
        _isHandlingComplete = false;
      });
    }
  }

  @override
  void dispose() {
    _playingSub?.cancel();
    _positionSub?.cancel();
    _durationSub?.cancel();
    _completedSub?.cancel();
    _completeDebounceTimer?.cancel();
    super.dispose();
  }

  // ==================== æ­Œè¯ç›¸å…³æ–¹æ³• ====================

  /// åŠ è½½å½“å‰æ­Œæ›²çš„æ­Œè¯
  /// ä¼˜å…ˆçº§ç­–ç•¥ï¼š
  /// 1. æ•°æ®åº“æœ¬åœ°æ­Œè¯ï¼ˆ_currentSong.lyricsï¼‰- æœ€é«˜ä¼˜å…ˆçº§
  /// 2. æ–‡ä»¶ç¼“å­˜æ­Œè¯ï¼ˆlyricsç›®å½•ä¸­çš„ç¼“å­˜æ–‡ä»¶ï¼‰
  /// 3. ç½‘æ˜“äº‘ç½‘ç»œæ­Œè¯ï¼ˆå®æ—¶è·å–å¹¶ç¼“å­˜ï¼‰
  Future<void> loadLyrics({bool forceRefresh = false}) async {
    if (_currentSong == null) {
      _currentLyrics = null;
      _lyricsError = null;
      notifyListeners();
      return;
    }

    _isLoadingLyrics = true;
    _lyricsError = null;
    notifyListeners();

    try {
      print('ğŸ“ å¼€å§‹åŠ è½½æ­Œè¯: ${_currentSong!.title}');
      
      // ç­–ç•¥1: ä¼˜å…ˆä½¿ç”¨æ•°æ®åº“ä¸­çš„æœ¬åœ°æ­Œè¯ï¼ˆé™¤éå¼ºåˆ¶åˆ·æ–°ï¼‰
      if (!forceRefresh && 
          _currentSong!.lyrics != null && 
          _currentSong!.lyrics!.trim().isNotEmpty) {
        try {
          print('  âœ… å°è¯•ä½¿ç”¨æ•°æ®åº“æœ¬åœ°æ­Œè¯');
          final parsedLyrics = LyricParser.parseLrc(_currentSong!.lyrics!);
          _currentLyrics = parsedLyrics.copyWith(source: 'local');
          _lyricsError = null;
          _isLoadingLyrics = false;
          print('  âœ… æˆåŠŸåŠ è½½æœ¬åœ°æ­Œè¯');
          notifyListeners();
          return;
        } catch (e) {
          print('  âš ï¸ æœ¬åœ°æ­Œè¯è§£æå¤±è´¥: $eï¼Œå°†å°è¯•å…¶ä»–æ¥æº');
          // ç»§ç»­å°è¯•ç¼“å­˜æˆ–ç½‘ç»œè·å–
        }
      } else if (forceRefresh) {
        print('  ğŸ”„ å¼ºåˆ¶åˆ·æ–°æ¨¡å¼ï¼Œè·³è¿‡æœ¬åœ°æ­Œè¯');
      } else {
        print('  âš ï¸ æ•°æ®åº“æ— æ­Œè¯ï¼Œå°è¯•ç¼“å­˜æˆ–ç½‘ç»œè·å–');
      }

      // ç­–ç•¥2 & 3: ä½¿ç”¨æ™ºèƒ½è·å–ï¼ˆè‡ªåŠ¨å¤„ç†ç¼“å­˜ -> ç½‘ç»œï¼‰
      final music = await _convertSongToMusic(_currentSong!);
      
      if (forceRefresh) {
        print('  ğŸ”„ å¼ºåˆ¶åˆ·æ–°ï¼šåˆ é™¤æ—§ç¼“å­˜');
        final uniqueKey = '${music.id}_${music.source}';
        await lyricService.deleteLyricCache(uniqueKey);
      }

      print('  ğŸŒ è°ƒç”¨æ™ºèƒ½æ­Œè¯è·å–æœåŠ¡');
      final lyrics = await lyricService.smartFetchLyrics(music);
      _currentLyrics = lyrics;
      _lyricsError = null;
      
      // å¦‚æœä»ç½‘ç»œè·å–æˆåŠŸï¼Œè‡ªåŠ¨ä¿å­˜åˆ°æ•°æ®åº“
      if (lyrics.source == 'netease' && lyrics.rawOriginalLyrics.isNotEmpty) {
        print('  ğŸ’¾ å°†ç½‘æ˜“äº‘æ­Œè¯ä¿å­˜åˆ°æ•°æ®åº“');
        try {
          await MusicDatabase.database.updateSong(
            _currentSong!.copyWith(lyrics: Value(lyrics.rawOriginalLyrics)),
          );
          // æ›´æ–°å½“å‰æ­Œæ›²å¯¹è±¡ï¼Œä¸‹æ¬¡å¯ä»¥ç›´æ¥ä½¿ç”¨
          _currentSong = _currentSong!.copyWith(lyrics: Value(lyrics.rawOriginalLyrics));
        } catch (e) {
          print('  âš ï¸ ä¿å­˜æ­Œè¯åˆ°æ•°æ®åº“å¤±è´¥: $e');
        }
      }
      
      print('  âœ… æ­Œè¯åŠ è½½æˆåŠŸï¼Œæ¥æº: ${lyrics.source}');
    } catch (e) {
      print('  âŒ åŠ è½½æ­Œè¯å¤±è´¥: $e');
      _currentLyrics = null;
      _lyricsError = e.toString();
    } finally {
      _isLoadingLyrics = false;
      notifyListeners();
    }
  }

  /// æ›´æ–°æ­Œè¯ï¼ˆç”¨äºç¼–è¾‘ã€æœç´¢åï¼‰
  void updateLyrics(ParsedLrc lyrics) {
    _currentLyrics = lyrics;
    _lyricsError = null;
    notifyListeners();
  }

  /// æ¸…é™¤æ­Œè¯
  void clearLyrics() {
    _currentLyrics = null;
    _lyricsError = null;
    notifyListeners();
  }

  /// æ›´æ–°å½“å‰æ’­æ”¾çš„æ­Œæ›²ï¼ˆç”¨äºå–œæ¬¢çŠ¶æ€ç­‰å˜æ›´ï¼‰
  void updateCurrentSong(Song updatedSong) {
    if (_currentSong?.id == updatedSong.id) {
      _currentSong = updatedSong;
      
      // åŒæ—¶æ›´æ–°æ’­æ”¾åˆ—è¡¨ä¸­çš„æ­Œæ›²
      final playlistIndex = _playlist.indexWhere((s) => s.id == updatedSong.id);
      if (playlistIndex != -1) {
        _playlist[playlistIndex] = updatedSong;
      }
      
      // æ›´æ–°åŸå§‹æ’­æ”¾åˆ—è¡¨
      final originalIndex = _originalPlaylist.indexWhere((s) => s.id == updatedSong.id);
      if (originalIndex != -1) {
        _originalPlaylist[originalIndex] = updatedSong;
      }
      
      // æ›´æ–°éšæœºæ’­æ”¾åˆ—è¡¨
      final shuffledIndex = _shuffledPlaylist.indexWhere((s) => s.id == updatedSong.id);
      if (shuffledIndex != -1) {
        _shuffledPlaylist[shuffledIndex] = updatedSong;
      }
      
      notifyListeners();
    }
  }

  /// å°† Song è½¬æ¢ä¸º Musicï¼ˆç”¨äºæ­Œè¯æœåŠ¡ï¼‰
  Future<Song> _convertSongToMusic(Song song) async {
    // ç›´æ¥è¿”å›Songå¯¹è±¡ï¼Œå› ä¸ºSongå°±æ˜¯æˆ‘ä»¬éœ€è¦çš„ç±»å‹
    return song;
  }
}
